#' Generates two vectorizations of a covariance matrix, each with row and column names stored explicitly as character vectors.
#' Vectorizations are to be used as predictor and outcome variables in a regression to estimate factor loadings and standard errors
#' Can apply weighting for application of FABIN3 or meta-analysis
#'
#' @param my_cov covariance matrix to be factor-analyzed, must have row and column names
#' @param indicators names of variables assumed to have loadings of 1 on the latent factors (character vector)
#' @param weighting One of "FABIN3", "meta", or neither: reweight the vectorized covariance matrix for FABIN3 or in a meta-analysis?
#' @return a list containing tidy_Xs, a vectorized covariance matrix of factor indicator variables,  tidy_Ys, a vectorized covariance matrix of model-implied instrumental variables, and tidy_MIIVs, a character vector naming model-implied instrumental variables.
tidy_XY <- function(my_cov, indicators, weighting = "NEITHER") {

  ## Given as imput a named covariance matrix
  ## and the character vector giving the indicators' names,
  ## format into a s_32 outcome vector and a s_31 predictor vector
  ## return a local_regress functiona


  long_covmat <- my_cov %>% data.frame() %>% rownames_to_column() %>% group_by(rowname)  %>% do(gather(., key= "variable")) %>% filter(variable != "rowname")

  tidy_MIIVs <- long_covmat %>% filter(!rowname %in% indicators) %>% pull(rowname) %>% unique

  ### Rows not in indicators, columns in indicators
  tidy_Xs <- long_covmat %>% filter((!rowname %in% indicators) & (variable %in% indicators))

  ## rows not in indicators, columns _also_ not in indicators
  tidy_Ys <- long_covmat %>% filter((!rowname %in% indicators) & (!variable %in% indicators))

  if (weighting == "FABIN3") {
    my_sqrt <- chol(solve(my_cov[tidy_MIIVs, tidy_MIIVs, drop = FALSE]))
    tidy_Xw <- tidy_Xs %>% group_by(variable) %>% do( data.frame(`[`(.,"rowname"), my_sqrt%*%data.matrix(`[`(.,"value"))) ) %>% ungroup()

    tidy_Yw <- tidy_Ys %>% group_by(variable) %>% do( data.frame(`[`(.,"rowname"), my_sqrt%*%data.matrix(`[`(.,"value")))) %>% ungroup()

    tidy_Xs <- left_join(tidy_Xs, tidy_Xw, by = c("variable", "rowname"))
    tidy_Ys <- left_join(tidy_Ys, tidy_Yw, by = c("variable", "rowname"))

  } else if (weighting == "meta") {
    ## Figure out a rationale for such weighting
  }

  return(list(tidy_Xs = tidy_Xs, tidy_Ys = tidy_Ys, tidy_MIIVs = tidy_MIIVs))
}


#' Function to generate factor loadings and standard errors from a vectorized covariance matrix having factor indicators and model-implied instrumental variables
#' @param tidy_Xs tidy_Xs, a vectorized covariance matrix of factor indicator variables, generated by \code{\link{tidy_XY}}
#' @param tidy_Ys a vectorized covariance matrix of model-implied instrumental variables, generated by \code{\link{tidy_XY}}
#' @param tidy_MIIVs character vector naming model-implied instrumental variables, generated by \code{\link{tidy_XY}}
#' @inheritParams tidy_XY
#' @return results frame, a data frame containing factor loadings and their heteroscedasticity consistent standard errors
FABIN <- function(tidy_Xs, tidy_Ys, tidy_MIIVs, indicators, my_cov){

  local_regress <- function(rowid){
    local_tidy_Y <- tidy_Ys %>% filter(rowname != rowid,variable == rowid) %>% pull(value) %>% data.matrix
    local_tidy_X <- tidy_Xs %>% filter(rowname != rowid) %>% spread(variable, value) %>% `[`( ,-1) %>% data.matrix
    local_lm <- lm(local_tidy_Y ~ 0 + local_tidy_X)
    return(local_lm)
  }

  ### map local regress to the non-indicator rownames and reduce to a column vector of loadings
  coefs <- sapply(X = tidy_MIIVs, FUN = function(x){coefficients(local_regress(x))})
  vcovs  <- sapply(X = tidy_MIIVs, FUN = function(x){sqrt(diag(vcovHC(local_regress(x), type = "HC0")))})


  if (length(indicators) > 1){

    coefs <- data.frame(t(coefs))
    vcovs  <- data.frame(t(vcovs))

    ### to be mapped to a list of study correlation matrices
    results_frame <- bind_cols(coefs, vcovs)
    names(results_frame) %<>% gsub(., pattern = "local_tidy_X", replacement = "") %>% gsub(., pattern = "1\\>", replacement = "SE")
    rownames(results_frame) <- tidy_MIIVs



  } else {

    coefs <- data.frame(coefs)
    vcovs  <- data.frame(vcovs)

    colnames(coefs) <- indicators
    colnames(vcovs) <- paste0(indicators, "SE")

    results_frame <- bind_cols(coefs, vcovs)
    rownames(results_frame) <- gsub(rownames(coefs), pattern = ".local_tidy_X", replacement = "")
  }
  ### then, add the indicators with their 1(0) loadings and SEs
  indicator_loadings <- matrix(0, nrow = length(indicators), ncol = (2*length(indicators)))

  rownames(indicator_loadings) <- indicators
  indicator_loadings <- data.frame(indicator_loadings)
  colnames(indicator_loadings) <- colnames(results_frame)
  results_frame <- rbind(results_frame, indicator_loadings)
  results_permute <- match(rownames(results_frame), rownames(my_cov))
  results_frame <- results_frame[results_permute,]

  for (ind in indicators){
    results_frame[ind,ind] <- 1
  }
  ### Then, order to match the original presentation in my_cov
  return(results_frame)
}

#' Calculate unique variances given a set of factor loadings and a sample covariance matrix, \eqn{\Psi}
#' @ineritParams tidy_XY
#' @param my_loadings named numeric matrix containing factor loadings
#' @return psi, a named diagonal matrix containing item unique variance estimates
IV_psi <- function(my_cov, my_loadings){

  my_loadings <- my_loadings[match(rownames(my_cov), rownames(my_loadings)),]

  Dmat <- my_loadings %*% solve(crossprod(my_loadings)) %*% t(my_loadings)

  Emat <- diag(1, nrow = nrow(Dmat)) - Dmat^2

  gvec <- diag(my_cov - Dmat%*%my_cov%*%Dmat)

  psi <- solve(Emat)%*%gvec
  psi <-  diag(as.vector(psi), nrow = length(psi))
  rownames(psi) <- rownames(my_cov)
  colnames(psi) <- rownames(my_cov)

  return(psi)
}


#' Estimate factor variance, or factor variance-covariance matrix, \eqn{\Phi}
#' @inheritParams IV_psi
#' @param my_psi diagonal matrix containing estimated factor unique variances
#' @return phi, factor variance-covariance matrix
IV_phi <- function(my_cov, my_loadings, my_psi){

  my_loadings <- my_loadings[match(rownames(my_cov), rownames(my_loadings)),]

  phi <- solve(crossprod(my_loadings))%*%t(my_loadings)%*%(my_cov - my_psi)%*%my_loadings%*% solve(crossprod(my_loadings))

  return(phi)

}
